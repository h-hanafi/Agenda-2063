---
title: "Agenda 2063 Progress Analysis"
author: "Hussam Hanafi"
date: "11/3/2019"
output: word_document
---

```{r setup, include = FALSE}
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(RColorBrewer)) install.packages("data.table", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(randomForest)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(xgboost)) install.packages("caret", repos = "http://cran.us.r-project.org")
options(digits = 3)

#Inputing AU Member Countries
AU <- c("Algeria", "Angola", "Benin", "Botswana", "Burkina Faso", "Burundi", "Cabo Verde", "Cameroon	Central African Republic", 
        "Chad", "Comoros",	"Congo, Dem. Rep.",	"Congo, Rep.",	"Cote d'Ivoire",	"Djibouti",	"Egypt Arab Rep.",	"Equatorial Guinea", "Eritrea",	
        "Eswatini",	"Ethiopia",	"Gabon", "Gambia, The",	"Ghana", "Guinea", "Guinea-Bissau",	"Kenya", "Lesotho", "Liberia",	"Libya",	"Madagascar", 
        "Malawi", "Mali",	"Mauritania",	"Mauritius",	"Morocco",	"Mozambique",	"Namibia",	"Niger", "Nigeria",	"Rwanda",	"Sao Tome and Principe", 
        "Senegal",	"Seychelles", "Sierra Leone",	"Somalia", "South Africa", "South Sudan",	"Sudan", "Tanzania", "Togo",	"Tunisia", "Uganda", 
        "Zambia", "Zimbabwe")
```

# Introduction

[Agenda 2063](https://au.int/en/agenda2063/overview) is the African Unions' Strategic framework for delivering inclusive and and sustainable development signed on May 2013.

As part of this agenda the AU has set over-arching goals and more granular targets to be achieved in the 50 years from 2013 to 2063.

The purpose of this report is to evaluate progress on two of those targets in the medium term [First Ten Year Implementation Plan](https://au.int/sites/default/files/documents/33126-doc-ten_year_implementation_book.pdf) by analyzing Indicator data from the [World Bank Open Data](https://data.worldbank.org/) Initiative.

## First Ten Year Implementation Plan Targets

The Two Targets were selected partially arbitrarily in the hope that they would be indicative of each other; however, the selection was also driven by the completeness of the data sets as there is often large gaps in data sets dealing with progress indicators due to a number of factors mostly affecting the data collection stage.

For this Report the two targets/indicators chosen were as follows:

* As part of the first Goal: A High Standard of Living, Quality of Life and Well Being for All; the FTYIP sets a target of reducing Unemployment relative 2013 by at least 25%
* As Part of the fourth Goal: Transformed Economies and Job Creation; the FTYIP sets a target of 7% Annual growth

This Report will use those two indicators to attempt to analyse progress and attempt to predict the value of these indicators by 2023.

# Data Analysis

We will analyse each of these indicators separately using the following steps:

1. Accessing the data from the World Bank Open Data web-site
2. Filtering out AU Member States
3. Wrangling the data into tidy format
4. Initial Visualization 
5. Wrangling the data to minimize the effect of missing data points
6. Visualizing the Data for Analysis Purposes
7. Sub-setting a Test Set to be used with our models

## Unemployment Rate

### Data Wrangling

We will start the with the Unemployment Rate, Loading the Data from the World Bank modeled estimate with the code below:

```{r Loading Unemployment Data, echo=TRUE, message=FALSE, warning=FALSE}
### Loading Unemployment Rate
## Creating Raw Data Folder
Raw_Data_Folder <- file.path(getwd(),"Raw_Data")
dir.create(Raw_Data_Folder)

##Downloading and Unpacking the File
#download.file("http://api.worldbank.org/v2/en/indicator/SL.UEM.TOTL.ZS?downloadformat=csv", 
#              file.path(Raw_Data_Folder,"API_SL.UEM.TOTL.ZS_DS2_en_csv_v2_422140.zip"), mode = "wb")
Unemployment_zip <- "API_SL.UEM.TOTL.ZS_DS2_en_csv_v2_422140.zip"
Unemployment_csv <- "API_SL.UEM.TOTL.ZS_DS2_en_csv_v2_422140.csv"
unzip(file.path(Raw_Data_Folder,Unemployment_zip), exdir = file.path(Raw_Data_Folder,"Unemployment"))

##Reading the File into R
Unemployment <- read_csv(file.path(Raw_Data_Folder,"Unemployment",Unemployment_csv), skip = 3)
```

Wrangling our Data into tidy format with the following code:

```{r Wrangling unemployment rate, echo=TRUE, message=FALSE, warning=FALSE}
## Tidying the Data
colnames(Unemployment) <- str_replace(colnames(Unemployment), " ", "_") 
Unemployment <- Unemployment %>%
  filter(Country_Name %in% AU) %>% 
  gather(key = "Year", value = "Unemployment", `1960`:`2019`, convert = TRUE) %>% 
  select(-c(X65,Indicator_Code)) %>% 
  filter(Country_Name %in% AU) %>% 
  select(-Country_Code, -Indicator_Name)
```

Below is a sample of the data frame:
```{r Unemployment data frame sample with NA}
Unemployment %>% sample_n(4) %>% knitr::kable(col.names = c("Country","Year","Unemployment rate"))
```

Our Initial Visualization of the data shows some clear places where we have missing data which we'll work to remove:

```{r Unemployemnt initial visualization, echo=FALSE, fig.height=7, fig.width=7}
## Viewing The Data
Unemployment %>% 
  ggplot(aes(Year,Country_Name, fill = Unemployment)) + 
  geom_tile(color = "black") + 
  scale_fill_distiller(palette = "Blues", na.value = "grey50", direction = 1, name = "Unemployment rate") +
  scale_x_continuous(expand = c(0,0)) + scale_y_discrete(expand = c(0,0)) + 
  theme(axis.text.y = element_text(hjust = 1)) +
  ylab("Country")
```

The below code achieves this:

```{r Unemployment Removing NAs, echo=TRUE}
## Removing years and countries with no data
No_Data <- Unemployment %>%
  group_by(Year) %>% summarize(No_Data = sum(!is.na(Unemployment))) 
Unemployment <- Unemployment %>% 
  left_join(No_Data, by = "Year") %>% filter(No_Data != 0) %>% select(-No_Data) 

No_Data <- Unemployment %>% group_by(Country_Name) %>% summarize(No_Data = sum(!is.na(Unemployment))) 
Unemployment <- Unemployment %>% 
  left_join(No_Data, by = "Country_Name") %>% filter(No_Data != 0) %>% select(-No_Data)
```

However since the stated goal is to reduce Unemployment by 25% relative to 2013 we will extract the 2013 values and use those as our Baseline; additionally, the below code will also set our test data and remove it from our training set:

```{r setting unemployment baseline and test sets, echo=TRUE}
## Setting Baseline and Test Sets
# Baseline
Unemployment %>% group_by(Country_Name) %>% filter(Year == c(2013)) %>% 
  summarize(Baseline = Unemployment) %>% filter(is.na(Baseline))

Baseline_Unemployment <- Unemployment %>% 
  group_by(Country_Name) %>% filter(Year == (2013)) %>% 
  summarize(Baseline = Unemployment) %>% filter(!is.na(Baseline))

# Tests Set
Unemployment %>% group_by(Country_Name) %>% filter(Year == c(2019)) %>% 
  summarize(Baseline = Unemployment) %>% filter(is.na(Baseline))

Unemployment_test <- Unemployment %>% filter(Year == 2019)

# Removing Test Data
Unemployment <- Unemployment %>% filter(Year != 2019) 
```

### Visualizations and Analysis

Now we are ready to Look at our data and extract some useful analyses. We repeat the initial visualization to confirm:

```{r Visualizing wrangled unemployment data, echo=FALSE, fig.height=7, fig.width=7}
# Viewing the Data
Unemployment %>% 
  ggplot(aes(Year,Country_Name, fill = Unemployment)) + 
  geom_tile(color = "black") + 
  scale_fill_distiller(palette = "Blues", na.value = "black", direction = 1, name = "Unemployment rate") + 
  scale_x_continuous(expand = c(0,0)) + scale_y_discrete(expand = c(0,0)) +
  ylab("Country") +
  theme(panel.background = element_rect(fill = "grey50", color = "black"), panel.grid = element_line(color = "grey50"))
```

Next we Look at the Continent Wide Average Unemployment rate and try discern any trends:

```{r continent wide unemployment, echo=FALSE, message=FALSE, warning=FALSE}
# Continent Wide Trend
Unemployment %>% group_by(Year) %>% summarize(Africa_Unemployment = mean(Unemployment)) %>% 
  ggplot(aes(Year,Africa_Unemployment)) + 
  geom_point() + geom_smooth(span = 0.75) +
  ylab("AU Average Unemployment rate")
```

We can clearly see a downward trend with a potential leveling off, however this doesn't provide a meaningful  comparison to the stated target, instead we take a comparison between the average and the baseline we set:

```{r Continent wide unemployment relative to baseline, echo=FALSE, message=FALSE, warning=FALSE}
# Percentage difference between AU Average and the 2013 Baseline
Unemployment %>% left_join(Baseline_Unemployment) %>% 
  group_by(Year) %>% 
  summarize(Africa_Unemployment = mean(Unemployment), Baseline = mean(Baseline)) %>% 
  mutate(Difference_to_Baseline = (Africa_Unemployment - Baseline)/Baseline) %>% 
  ggplot(aes(Year,Difference_to_Baseline)) + 
  geom_point() + 
  geom_smooth() +
  geom_vline(xintercept = 2013, linetype = 2, color = "blue") + 
  geom_hline(data = data_frame(yintercept = c(-0.25,0), color = c("black","red")),
                        aes(yintercept = yintercept, color = color),linetype = c(2,1),show.legend = FALSE) + 
  geom_text(data = data_frame(x = c(2013,2000), y = c(0.15,-0.25), label = c("2013", "25% below Baseline"), angle = c(90,0)), 
            aes(x = x, y = y, label = label, angle = angle, vjust = 1), size = 12 / .pt) + 
  scale_color_manual(values = c("red","black")) +
  ylab("Percentage difference between AU Average \n and the 2013 Baseline")
```

As expected we see the same trend, it is however clear that the continent wide performance leaves something to be desired with the reduction in Unemployment rate by 2019 not approaching the target.

A Box-plot showing the unemployment rate over the years paints a more nuanced picture showing large variations between Member States and a mean (in blue) that is significantly larger than the median implying that most member states are performing better than average:

```{r Unemployment continent wide boxplot, echo=FALSE, message=FALSE}
#Continent Wide Boxplot
Unemployment %>% group_by(Year) %>% mutate(Africa_Unemployment = mean(Unemployment)) %>%
  ggplot(aes(as.character(Year),Unemployment)) + 
  geom_boxplot() + 
  geom_point(aes(as.character(Year),Africa_Unemployment), color = "blue") +
  scale_color_distiller(palette = "Blues", na.value = "black", direction = 1, name = "Unemployment rate") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.25)) + 
  xlab("Year") +
  ylab("Unemployment rate")
```

To illustrate this variation we look at the two top and bottom performing countries in `r max(Unemployment$Year)`

```{r unemployment country sample visualizations, echo=FALSE, message=FALSE}
Country_Sample <- Unemployment %>% 
  filter(Year == max(Year)) %>% 
  left_join(Baseline_Unemployment) %>%  
  mutate(Difference_to_Baseline = (Unemployment - Baseline)/Baseline) %>% 
  mutate(Country_Name = reorder(Country_Name,Difference_to_Baseline)) %>% 
  top_n(-2) %>%
  pull(Country_Name) %>% unique() %>% as.character()

Country_Sample <- Unemployment %>% 
  filter(Year == max(Year)) %>% 
  left_join(Baseline_Unemployment) %>%  
  mutate(Difference_to_Baseline = (Unemployment - Baseline)/Baseline) %>% 
  mutate(Country_Name = reorder(Country_Name,Difference_to_Baseline)) %>% 
  top_n(2) %>% 
  pull(Country_Name) %>% unique() %>% as.character() %>% 
  c(.,Country_Sample)

Unemployment %>% 
  filter(Country_Name %in% Country_Sample) %>%
  left_join(Baseline_Unemployment) %>%  
  mutate(Difference_to_Baseline = (Unemployment - Baseline)/Baseline) %>% 
  mutate(Country_Name = reorder(Country_Name,Difference_to_Baseline)) %>%
  ggplot(aes(Year,Difference_to_Baseline)) + 
  geom_point() + 
  geom_smooth(span = 1) + 
  facet_wrap(~Country_Name, scales = "free") + 
  geom_hline(yintercept = -0.25, color = "red", linetype = 2) + 
  ylab("Percentage difference between Unemployment rate \n and the 2013 Baseline")
```

## Annual GDP Growth

We Repeat this process with data relating to GDP Growth, in this section of the report we will show less of the code as there are essential similarities in the process.

### Data Wrangling

Once we have loaded and wrangled the Annual GDP Growth Data from the World Bank Open Data website

```{r Wrangling GDP data, message=FALSE, warning=FALSE, include=FALSE}
## Downloading and unpacking file
#download.file("http://api.worldbank.org/v2/en/indicator/NY.GDP.MKTP.KD.ZG?downloadformat=csv", 
#              file.path(Raw_Data_Folder,"API_NY.GDP.MKTP.KD.ZG_DS2_en_csv_v2_422196.zip"), mode = "wb")
GDP_Growth_zip <- "API_NY.GDP.MKTP.KD.ZG_DS2_en_csv_v2_422196.zip"
GDP_Growth_csv <- "API_NY.GDP.MKTP.KD.ZG_DS2_en_csv_v2_422196.csv"
unzip(file.path(Raw_Data_Folder,GDP_Growth_zip), exdir = file.path(Raw_Data_Folder,"GDP_Growth"))

#Reading the File into R
GDP_Growth <- read_csv(file.path(Raw_Data_Folder,"GDP_Growth",GDP_Growth_csv), skip = 3)

## Tidying the Data
colnames(GDP_Growth) <- str_replace(colnames(GDP_Growth), " ", "_") 
GDP_Growth <- GDP_Growth %>% 
  filter(Country_Name %in% AU) %>% 
  gather(key = "Year", value = "GDP_Growth", `1960`:`2019`, convert = TRUE) %>% 
  select(-c(X65,Indicator_Code)) %>% 
  filter(Country_Name %in% AU) %>% 
  select(-Country_Code, -Indicator_Name)
```

Below is a sample of our tidied data:

```{r GDP Data sample, echo=FALSE}
GDP_Growth %>% sample_n(4) %>% knitr::kable(col.names = c("Country","Year","Unemployment rate"))
```

While here we make our initial visualization; it's important to not that for the sake of clarity outliers in both directions were scaled down to 25% and -25% Growth rate respectively:

```{r GDP initial visualization, echo=FALSE, fig.height=7, fig.width=7}
## Viewing The Data
GDP_Growth %>% 
  mutate(GDP_Growth = ifelse(GDP_Growth >= 25,25,GDP_Growth), 
         GDP_Growth = ifelse(GDP_Growth <= -25,-25,GDP_Growth)) %>%
  ggplot(aes(Year,Country_Name, fill = GDP_Growth)) + 
  geom_tile(color = "black") + 
  scale_fill_distiller(palette = "RdBu", na.value = "grey50", direction = 1, name = "Annual GDP Growth") +
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_discrete(expand = c(0,0)) + 
  theme(panel.background = element_rect(fill = "grey50", color = "black"), 
        panel.grid = element_line(color = "grey50")) +
  ylab("Country")
```

We can see that the missing data is more sporadic than with the Unemployment rate, we clean up the missing data, opting to estimate missing data points for our test set with data from the closest year. The exception to this is Somalia where the latest data is from 1990 thus we exclude it from this analysis.

```{r Wrangling and test data creation for GDP, message=FALSE, warning=FALSE, include=FALSE}
## Removing years and countries with no data
No_Data <- GDP_Growth %>%
  group_by(Year) %>% summarize(No_Data = sum(!is.na(GDP_Growth))) 
GDP_Growth <- GDP_Growth %>% 
  left_join(No_Data, by = "Year") %>% filter(No_Data != 0) %>% select(-No_Data) 

No_Data <- GDP_Growth %>% 
  group_by(Country_Name) %>% summarize(No_Data = sum(!is.na(GDP_Growth))) 
GDP_Growth <- GDP_Growth %>% 
  left_join(No_Data, by = "Country_Name") %>% filter(No_Data != 0) %>% select(-No_Data) 

## Tests Set
GDP_Growth %>% group_by(Country_Name) %>% filter(Year == 2018) %>% 
  summarize(Baseline = GDP_Growth) %>% filter(is.na(Baseline))

GDP_Growth %>% filter(Country_Name == "Eritrea") %>% filter(!is.na(GDP_Growth)) %>% tail()
Eritrea_2018 <- GDP_Growth %>% filter(Country_Name == "Eritrea", Year == 2011) %>% mutate(Year = 2018)

GDP_Growth %>% filter(Country_Name == "South Sudan") %>% filter(!is.na(GDP_Growth)) %>% tail()
South_Sudan_2018 <- GDP_Growth %>% filter(Country_Name == "South Sudan", Year == 2016) %>% mutate(Year = 2018)

GDP_Growth %>% filter(Country_Name == "Somalia") %>% filter(!is.na(GDP_Growth)) %>% tail()

GDP_Growth_test <- GDP_Growth %>% 
  filter(Year == 2018, !Country_Name %in% c("Somalia","Eritrea","South Sudan")) %>% 
  rbind(Eritrea_2018) %>% rbind(South_Sudan_2018)

#Removing Test Data
GDP_Growth <- GDP_Growth %>% filter(Year != 2018) 

#Removing NA's
GDP_Growth <- GDP_Growth %>% filter(!is.na(GDP_Growth))

#Removing Somalia
GDP_Growth <- GDP_Growth %>% filter(Country_Name != "Somalia")
```

We now visualize the data in our Wrangled data set after the exclusion of the Test data

```{r post wrangling GPD visualization, echo=FALSE, fig.height=7, fig.width=7, message=FALSE, warning=FALSE}
## Viewing the Data
GDP_Growth %>%   
  mutate(GDP_Growth = ifelse(GDP_Growth >= 25,25,GDP_Growth), 
         GDP_Growth = ifelse(GDP_Growth <= -25,-25,GDP_Growth)) %>%
  ggplot(aes(Year,Country_Name, fill = GDP_Growth)) + 
  geom_tile(color = "black") + 
  scale_fill_distiller(palette = "RdBu", na.value = "grey50", direction = 1, name = "Annual GDP Growth") + 
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_discrete(expand = c(0,0)) + 
  theme(panel.background = element_rect(fill = "grey50", color = "black"), 
        panel.grid = element_line(color = "grey50")) +
  ylab("Country")
```

### Visualization and Analysis

We start by looking for Continent wide trends:

```{r GDP continent wide trend, echo=FALSE, message=FALSE, warning=FALSE}
## Continent Wide Trend
GDP_Growth %>% group_by(Year) %>% summarize(Africa_GDP_Growth = mean(GDP_Growth)) %>% 
  ggplot(aes(Year,Africa_GDP_Growth)) + 
  geom_point() + 
  geom_hline(yintercept = 7, color = "red", linetype = 2) + 
  geom_vline(xintercept = 2013, color = "blue", linetype = 2) +
  geom_smooth(span = 0.75) +
  geom_text(data = data.frame(x = c(1995, 2013), 
                              y = c(7,2), 
                              label = c("Target Growth = 7%","2013"), 
                              angle = c(0,90), vjust = 1, 
                              fontface = "italic", size = 12 / .pt), 
            aes(label = label, 
                x = x, y = y, 
                angle = angle, 
                vjust= vjust, 
                fontface = fontface, 
                size = size), 
            show.legend = FALSE) + 
  ylab("Annual GPD Growth: \n Continent Wide")
```

The Scatter plot shows a massive variation from year to year with most of the years falling below the 7% Target. A Box-plot confirms this variation; please note that for clarity we only look at a subset of the years and  do not show the largest outliers:

```{r GDP continent Wide Boxplot, echo=FALSE, message=FALSE, warning=FALSE}
## Continent Wide Boxplot
GDP_Growth %>% filter(Year >= 2005) %>%
  group_by(Year) %>% mutate(Africa_GDP_Growth = mean(GDP_Growth)) %>%
  ggplot(aes(as.character(Year),GDP_Growth)) + 
  geom_boxplot() + 
  geom_point(aes(as.character(Year),Africa_GDP_Growth), color = "blue") +
  geom_hline(yintercept = 7, color = "red", linetype = 2) +
  scale_color_distiller(palette = "Blues", na.value = "black", direction = 1) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.25)) + 
  xlab("Year") +
  ylab("Annual GDP Growth Rate") +
  ylim(-25,25)
```

From here it is clear that the majority of Member states are not achieving the set target of 7%, a look at the countries with the highest and lowest growth rates provides a clearer picture of individual trends:

```{r GDP Country Sample, echo=FALSE, message=FALSE, warning=FALSE}
## Country Sample analysis
Country_Sample <- GDP_Growth %>% 
  filter(Year == max(Year)) %>% 
  mutate(Country_Name = reorder(Country_Name,GDP_Growth)) %>% 
  top_n(2) %>%
  pull(Country_Name) %>% unique() %>% as.character()

Country_Sample <- GDP_Growth %>% 
  filter(Year == max(Year)) %>% 
  mutate(Country_Name = reorder(Country_Name,GDP_Growth)) %>% 
  top_n(-2) %>% 
  pull(Country_Name) %>% unique() %>% as.character() %>% 
  c(.,Country_Sample)

GDP_Growth %>% 
  filter(Country_Name %in% Country_Sample) %>%
  ggplot(aes(Year,GDP_Growth)) + 
  geom_point() + 
  geom_smooth(span = 1) + 
  facet_wrap(~Country_Name, scale = "free") + 
  geom_hline(yintercept = 7, color = "red", linetype = 2) + 
  ylab("Annual GDP Growth")
```

However it fails to give us an idea of what countries are performing since a consistent growth is just as if not more important than a high growth rate; additionally, countries like Libya with high variation that suffer large GDP losses can skew the trend by making equally large gains.

We propose that looking at the proportion of years the target is reached is a more indicative metric:

```{r Proportion of years target was met, echo=FALSE, fig.height=7, fig.width=7}
## Proportion of years were target was met
GDP_Growth %>% 
  group_by(Country_Name) %>% 
  summarise(Growth_Target = mean(GDP_Growth > 7)) %>%
  mutate(Country_Name = reorder(Country_Name,Growth_Target)) %>%
  ggplot(aes(Country_Name,Growth_Target)) +
  geom_bar(stat = "identity") + 
  coord_flip() + 
  xlab("Country") + ylab("Proportion of Years Target is reached") +
  scale_y_continuous(expand = c(0,0)) + 
  scale_x_discrete(expand = c(0,0))
```

If we narrow our view to the years since the launch of Agenda 2063 we get yet a different look at how Member States are performing:

```{r Proportion of years since 2013, echo=FALSE, fig.height=7, fig.width=7}
GDP_Growth %>% 
  group_by(Country_Name) %>% 
  filter(Year >= 2013) %>% 
  summarise(Growth_Target = mean(GDP_Growth > 7)) %>% 
  mutate(Country_Name = reorder(Country_Name,Growth_Target)) %>%
  ggplot(aes(Country_Name,Growth_Target)) + geom_bar(stat = "identity") + 
  coord_flip() + 
  xlab("Country") + ylab("Proportion of Years Target is reached  \n since 2013") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_y_continuous(expand = c(0,0)) + 
  scale_x_discrete(expand = c(0,0)) 
```


# Methodology

Building our model we will use 10 fold Cross-Validation across all models. For the purposes of this report we will compare four models:

1. Linear Regression
2. K-Nearest Neighbors
3. Gradient Boosting
4. Random Forest

To determine the effectiveness of our models we will use the Root Mean Square Error between our predictions and the test set as a measure; optimizing our parameters as we go along.

## Unemployment Rate

First we will Build our model for the Unemployment rate, attempting to predict the unemployment rate at the FTYIP or 2023.

### Building the Model

The below code builds the model using the four methods below.

```{r Unemployment Model, echo=TRUE, message=FALSE, warning=FALSE}
### model
## 10 Fold CV
Control <- trainControl(method = "cv", number = 15, p = 0.9)

##Linear Regression
fit_lm_Unemployment <- train(Unemployment ~ ., data = Unemployment, 
                             method = "lm", trControl = Control)
pred_lm_Unemployment <- predict(fit_lm_Unemployment, newdata = Unemployment_test)
RMSE_lm <- sqrt(mean((pred_lm_Unemployment - Unemployment_test$Unemployment)^2))

## K-Nearest Neighbors
tune = data.frame(k = 1:5)
fit_knn_Unemployment <- train(Unemployment ~ ., data = Unemployment, 
                              method = "knn", tuneGrid = tune, trControl = Control)

pred_knn_Unemployment <- predict(fit_knn_Unemployment, newdata = Unemployment_test)
RMSE_knn <- sqrt(mean((pred_knn_Unemployment - Unemployment_test$Unemployment)^2))

## Extreme Gradient Boosting
tune <- expand.grid(nrounds = seq(200,300,50), lambda = seq(1,3,0.5), alpha = c(0,1e-04), eta = 0.3)
fit_xgb_Unemployment <- train(Unemployment ~ ., data = Unemployment, 
                              method = "xgbLinear", tuneGrid = tune, trControl = Control)
pred_xgb_Unemployment <- predict(fit_xgb_Unemployment, newdata = Unemployment_test)
RMSE_xgb <- sqrt(mean((pred_xgb_Unemployment - Unemployment_test$Unemployment)^2))

## Random Forest
tune = data.frame(mtry = seq(40,50,5))
fit_rf_Unemployment<- train(Unemployment ~ ., data = Unemployment, 
                            method = "rf", tuneGrid = tune, trControl = Control)
pred_rf_Unemployment <- predict(fit_rf_Unemployment, newdata = Unemployment_test)
RMSE_rf <- sqrt(mean((pred_rf_Unemployment - Unemployment_test$Unemployment)^2))

## Storing the Results
Results_Unemployment <- data_frame(method = c("lm","knn","xgb","rf"), 
                                   RMSE = c(RMSE_lm,RMSE_knn,RMSE_xgb,RMSE_rf))

fit_Unemployment <- list(lm = fit_lm_Unemployment, knn = fit_knn_Unemployment, 
                         xgb = fit_xgb_Unemployment, rf = fit_rf_Unemployment)
Best_fit_Unemployment <- fit_Unemployment[[Results_Unemployment$method[which.min(Results_Unemployment$RMSE)]]]
```

Plotting our Parameters against the RMSE allows us to ensure that our model is optimized, below is an example using the k-Nearest Neighbors Model:

```{r Unemployment Parameters, echo=FALSE}
plot(fit_knn_Unemployment)
```
The results from each of our Models can be seen below:

```{r unemployment Model Results, echo=FALSE}
Results_Unemployment %>% mutate(method = c("Linear Model", "k-Nearest Neighbors","Gradient Boosting", "Random Forest")) %>%  knitr::kable(col.names = c("Method","RMSE"))
```

Thus the best performing methodology is:

```{r Unemployment best performing model, echo=FALSE, message=FALSE, warning=FALSE}
Results_Unemployment %>% mutate(method = c("Linear Model", "k-Nearest Neighbors","Gradient Boosting", "Random Forest")) %>% mutate(method = reorder(method,RMSE)) %>% top_n(-1) %>% knitr::kable(col.names = c("Method","RMSE"))
```
  
### FTYIP Prediction

Now we will use our model to predict the Unemployment rate for the year 2023. The Prediction can be generated with the following code:

```{r Unemployment 2023 prediction, echo=TRUE, message=FALSE, warning=FALSE}
Unemployment_2023 <- Unemployment_test %>% 
  mutate(Year = 2023) %>% select(-Unemployment)

Unemployment_2023 <- Unemployment_2023 %>% 
  mutate(Unemployment = predict(Best_fit_Unemployment, newdata = Unemployment_2023)) %>% 
  left_join(Baseline_Unemployment, by = "Country_Name") %>% 
  mutate(Difference_to_Baseline = (Unemployment - Baseline)/Baseline)

mu_Unemployment_2023 <- Unemployment_2023 %>% summarize(mean(Difference_to_Baseline)) %>% pull()
```

Visualizing the distribution of the Percentage difference between the Prediction and the Baseline data gives us an indication of how progress towards the target is distributed:

```{r unemployment 2023 distribution, echo=FALSE}
Unemployment_2023 %>%
  ggplot(aes(Difference_to_Baseline)) +
  geom_histogram(bins = 40, color = "black") + 
  geom_vline(xintercept = mu_Unemployment_2023, color = "blue", linetype = 2) + 
  scale_y_continuous(expand = c(0,0)) + 
  xlab("Percentage Difference between the Unemployment rate and the Baseline")
```

We can see a number of outliers on the high end; otherwise, the result is tightly distributed with most Member States managing to reduce unemployment performing at or better than the Continent Wide average of `r mu_Unemployment_2023*100`%. This average is much lower than the target set in the FTYIP and is such a cause for concern.

Unfortunately, our predictions indicate that only two States succeed in achieving the 2023 target of 25% reduction in the Unemployment rate:

```{r Unemployment rate successful countries, echo=FALSE}
Unemployment_2023 %>% filter(Difference_to_Baseline <= -0.25) %>% 
  select(Country_Name, Unemployment, Difference_to_Baseline) %>%
  mutate(Difference_to_Baseline = Difference_to_Baseline * 100) %>%
  knitr::kable(col.names = c("Country","Unemployment rate","Percentage Difference to Baseline"))
```

Visualizing the Unemployment data for these states shows us that the prediction is consistent with the trend they have been exhibiting:

```{r Visualizing Success for Unemployment rate, echo=FALSE, message=FALSE, warning=FALSE}
Unemployment_2023 %>% 
  filter(Difference_to_Baseline <= -0.25) %>% select(Country_Name) %>% 
  inner_join(Unemployment, by = c("Country_Name")) %>% 
  left_join(Baseline_Unemployment) %>% 
  mutate(Difference_to_Baseline = (Unemployment - Baseline)/Baseline) %>%
  ggplot(aes(Year, Difference_to_Baseline)) + 
  geom_point(show.legend = FALSE) + 
  geom_hline(yintercept = -0.25, color = "red", linetype =2) + 
  geom_smooth(span = 0.75) +
  facet_grid(Country_Name~.) + 
  ylab("Percentage Difference between Baseline Unemployment rate and \n Predicted Unemployment rate")
```

## Annual GDP Growth

We will repeat the same steps to model the Annual GDP Growth.

### Building the Model

Once again we use 10 fold cross Validation and the same four modelling methodologies as before.

```{r GDP Model, message=FALSE, warning=FALSE, include=FALSE}
### Building the model

## Linear Regression
fit_lm_GDP_Growth <- train(GDP_Growth ~ ., data = GDP_Growth, method = "lm", trControl = Control)
pred_lm_GDP_Growth <- predict(fit_lm_GDP_Growth, newdata = GDP_Growth_test)
RMSE_lm <- sqrt(mean((pred_lm_GDP_Growth - GDP_Growth_test$GDP_Growth)^2))

## K-Nearest Neighbours
tune = data.frame(k = 1:10)
fit_knn_GDP_Growth <- train(GDP_Growth ~ ., data = GDP_Growth, method = "knn", tuneGrid = tune, trControl = Control)
pred_knn_GDP_Growth <- predict(fit_knn_GDP_Growth, newdata = GDP_Growth_test)
RMSE_knn <- sqrt(mean((pred_knn_GDP_Growth - GDP_Growth_test$GDP_Growth)^2))

## Gradient Boosting
tune <- expand.grid(nrounds = seq(50,150,50), lambda = seq(0.6,1,0.1), alpha = c(0,1e-04,1), eta = 0.3)
fit_xgb_GDP_Growth <- train(GDP_Growth ~ ., data = GDP_Growth, method = "xgbLinear", tuneGrid = tune, trControl = Control )
pred_xgb_GDP_Growth <- predict(fit_xgb_GDP_Growth, newdata = GDP_Growth_test)
RMSE_xgb <- sqrt(mean((pred_xgb_GDP_Growth - GDP_Growth_test$GDP_Growth)^2))

## Random Forest
tune = data.frame(mtry = seq(5,15,1))
fit_rf_GDP_Growth <- train(GDP_Growth ~ ., data = GDP_Growth, method = "rf", tuneGrid = tune, trControl = Control)
pred_rf_GDP_Growth <- predict(fit_rf_GDP_Growth, newdata = GDP_Growth_test)
RMSE_rf <- sqrt(mean((pred_rf_GDP_Growth - GDP_Growth_test$GDP_Growth)^2))

## Inputing the Results
Results_GDP_Growth <- data_frame(method = c("lm","knn","xgb","rf"), RMSE = c(RMSE_lm,RMSE_knn,RMSE_xgb,RMSE_rf))

fit_GDP_Growth <- list(lm = fit_lm_GDP_Growth, knn = fit_knn_GDP_Growth, xgb = fit_xgb_GDP_Growth, rf = fit_rf_GDP_Growth)

Best_fit_GDP_Growth <- fit_GDP_Growth[[Results_GDP_Growth$method[which.min(Results_GDP_Growth$RMSE)]]]
```

Below we can see the results for our Model

```{r Results gdp, echo=FALSE}
Results_GDP_Growth %>% mutate(method = c("Linear Regression","k-Nearest Neighbors","Gradient Boosting","Random Forest")) %>% knitr::kable(col.names = c("Method","RMSE"))
```

Thus our best performing model is:

```{r Best model gdp, echo=FALSE, message=FALSE, warning=FALSE}
Results_GDP_Growth %>% mutate(method = c("Linear Model", "k-Nearest Neighbors","Gradient Boosting", "Random Forest")) %>% mutate(method = reorder(method,RMSE)) %>% top_n(-1) %>% knitr::kable(col.names = c("Method","RMSE"))
```

We can confirm the optimization of our model parameters with a plot like the below for the Gradient Boosting method:

```{r gdp parameter plot, echo=FALSE}
plot(fit_xgb_GDP_Growth)
```

### FTYIP Prediction

Next we make predictions using our best performing model

```{r gdp 2023 prediction, include=FALSE}
GDP_Growth_2023 <- GDP_Growth_test %>% select(Country_Name) %>% mutate(Year = 2023)

GDP_Growth_2023 <- GDP_Growth_2023 %>% mutate(GDP_Growth = predict(Best_fit_GDP_Growth, newdata = GDP_Growth_2023))

mu_GDP_Growth_2023 <- GDP_Growth_2023 %>% summarise(AU_GDP_Growth = mean(GDP_Growth)) %>% pull()
```

We take a look at a sample of our predictions:

```{r gdp prediction sample, echo=FALSE}
GDP_Growth_2023 %>% sample_n(4) %>% knitr::kable(col.names = c("Country","Year","Annual GDP Growth"))
```

A more detailed a look at the distribution of our predictions show a large number of the Member states perform positively at or above the AU average of `r mu_GDP_Growth_2023`% even if they do not achieve the stated target of 7% Annual GDP Growth.

```{r gdp prediction histogram, echo=FALSE}
GDP_Growth_2023 %>%
  ggplot(aes(GDP_Growth)) +
  geom_histogram(bins = 20, color = "black") + 
  geom_vline(xintercept = mu_GDP_Growth_2023, color = "blue", linetype = 2) +
  scale_x_continuous(breaks = c(mu_GDP_Growth_2023,7,seq(-10,20,5))) + 
  scale_y_continuous(expand = c(0,0)) + 
  ylab("Annual GDP Growth")
```



Below we list the states that do meet our growth target:

```{r gdp countries meeting the target, echo=FALSE}
GDP_Growth_2023 %>% filter(GDP_Growth >= 7) %>% knitr::kable(col.names = c("Country","Year","Annual GDP Growth")) 
```

looking at the data for these countries we see that the apparent trend supports these predictions. The exception is Libya that has had a large variation around our growth target indicating a weakness in our model to account for them.

```{r scatter plot of countries meeting GDP targets, echo=FALSE, message=FALSE, warning=FALSE}
GDP_Growth_2023 %>% filter(GDP_Growth >= 7) %>% select(Country_Name) %>% 
  inner_join(GDP_Growth) %>%
  ggplot(aes(Year, GDP_Growth)) + 
  geom_point() + 
  geom_smooth(span = 1) +
  geom_hline(yintercept = 7, color = "red", linetype = 2) +
  scale_color_brewer("Country",palette = "Dark2") + 
  facet_wrap(Country_Name~., ncol = 2, scales = "free") + 
  ylab("Annual GDP Growth")
```

## Modeling the Combined Data Sets

### Wrangling the Data set

Finally, we combine the data sets for both indicators and redo our predictions for both indicators using the combined data set.

We achieve this alongside preparing our data sets using the following code:

```{r combining the data sets, echo=TRUE, message=FALSE, warning=FALSE}
#Preparing the Data
Model <- GDP_Growth %>% full_join(Unemployment)

#Removing years and countries with no data
No_Data <- Model %>%
  group_by(Year) %>% summarize(No_Data = sum(!is.na(Unemployment))) 
Model <- Model %>% left_join(No_Data, by = "Year") %>% filter(No_Data != 0) %>% select(-No_Data) 

No_Data <- Model %>% group_by(Country_Name) %>% summarize(No_Data = sum(!is.na(Unemployment))) 
Model <- Model %>% left_join(No_Data, by = "Country_Name") %>% filter(No_Data != 0) %>% select(-No_Data) 

No_Data <- Model %>%
  group_by(Year) %>% summarize(No_Data = sum(!is.na(GDP_Growth))) 
Model <- Model %>% left_join(No_Data, by = "Year") %>% filter(No_Data != 0) %>% select(-No_Data) 

No_Data <- Model %>% group_by(Country_Name) %>% summarize(No_Data = sum(!is.na(GDP_Growth))) 
Model <- Model %>% left_join(No_Data, by = "Country_Name") %>% filter(No_Data != 0) %>% select(-No_Data) 

#Removing NA's
Model <- Model %>% filter(!is.na(GDP_Growth))

#Setting Test Data
Unemployment_2018 <- Unemployment %>% filter(Year == 2018)
Model_test <- GDP_Growth_test %>% left_join(Unemployment_2018)

Model_test <- Model_test %>% filter(!is.na(GDP_Growth),!is.na(Unemployment))
```

### Visualizations

We view the new Data set first by GDP growth rate:

```{r combined model viewing GDP, echo=FALSE, fig.height=7, fig.width=7}
Model %>% 
  mutate(GDP_Growth = ifelse(GDP_Growth >= 25,25,GDP_Growth), 
         GDP_Growth = ifelse(GDP_Growth <= -25,-25,GDP_Growth)) %>%
  ggplot(aes(Year,Country_Name, fill = GDP_Growth)) + 
  geom_tile(color = "black") + 
  scale_fill_distiller(palette = "RdBu", na.value = "grey50", direction = 1, name = "Annual GDP Growth") + 
  scale_x_continuous(expand = c(0,0)) + scale_y_discrete(expand = c(0,0)) + 
  ylab("Country") +
  theme(axis.text.y = element_text(hjust = 1), 
        panel.background = element_rect(fill = "grey50", color = "black"), 
        panel.grid = element_line(color = "grey50"))
```

Then by Unemployment rate:

```{r combined model viewing unemployment, echo=FALSE, fig.height=7, fig.width=7}
Model %>% 
  ggplot(aes(Year,Country_Name, fill = Unemployment)) + 
  geom_tile(color = "black") + 
  scale_fill_distiller(palette = "Blues", na.value = "grey50", direction = 1, name = "Unemployment Rate") + 
  scale_x_continuous(expand = c(0,0)) + scale_y_discrete(expand = c(0,0)) + 
  ylab("Country") +
  theme(axis.text.y = element_text(hjust = 1), 
        panel.background = element_rect(fill = "grey50", color = "black"), 
        panel.grid = element_line(color = "grey50"))

```

Next we attempt to visualize the correlation between the two indicators across the years and for each member state. Ideally we would want to see a high negative correlation as we want to reduce Unemployment alongside a high GDP growth rate.

```{r correlation by year, echo=FALSE, message=FALSE, warning=FALSE}
Model %>% group_by(Year) %>% 
  summarize(cor = cor(GDP_Growth,Unemployment)) %>% 
  ggplot(aes(Year,cor)) + 
  geom_point(aes(color = ifelse(cor <= 0, "red","blue")), show.legend = FALSE) + 
  geom_hline(yintercept = 0) +
  geom_smooth(span = 0.8, alpha = 0.2,color = "black") +
   ylab("Correlation between Annual GDP Growth and \n Unemployment Rate")
```

The plot of correlation against year shows us that the correlation between the two indicators is not a constant but rather follows a downward trend implying  that as time goes on they are becoming better indicators of each other if only slightly.

Making a similar plot on a Country by Country basis helps explain the low continent wide correlation. There is a large variation across countries that then reduces the Continent wide average.

```{r correlation by country, echo=FALSE, fig.width=7}
Model %>% group_by(Country_Name) %>% summarize(cor = cor(GDP_Growth,Unemployment)) %>% 
  ggplot(aes(Country_Name,cor)) + 
  geom_point(aes(color = ifelse(cor <= 0, "red","blue")), show.legend = FALSE) + 
  geom_hline(yintercept = 0) +
  theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust = 0.25)) + 
  ylab("Correlation between Annual GDP Growth and \n Unemployment Rate") +
  xlab("Country")
```

### New Unemployment Model

```{r combined unemployment models, message=FALSE, warning=FALSE, include=FALSE}
fit_lm_Model_Unemployment <- train(Unemployment ~ ., data = Model, method = "lm", trControl = Control)
pred_lm_Model_Unemployment <- predict(fit_lm_Model_Unemployment, newdata = Model_test)
RMSE_lm <- sqrt(mean((pred_lm_Model_Unemployment - Model_test$Unemployment)^2))

tune = data.frame(k = 1:15)
fit_knn_Model_Unemployment <- train(Unemployment ~ ., data = Model, method = "knn", tuneGrid = tune, trControl = Control)
pred_knn_Model_Unemployment <- predict(fit_knn_Model_Unemployment, newdata = Model_test)
RMSE_knn <- sqrt(mean((pred_knn_Model_Unemployment - Model_test$Unemployment)^2))

tune <- expand.grid(nrounds = seq(300,400,50), lambda = seq(1,3,0.5), alpha = c(0,1e-04), eta = 0.3)
fit_xgb_Model_Unemployment <- train(Unemployment ~ ., data = Model, method = "xgbLinear", trControl = Control )
pred_xgb_Model_Unemployment <- predict(fit_xgb_Model_Unemployment, newdata = Model_test)
RMSE_xgb <- sqrt(mean((pred_xgb_Model_Unemployment - Model_test$Unemployment)^2))

tune = data.frame(mtry = seq(0,20,10))
fit_rf_Model_Unemployment <- train(Unemployment ~ ., data = Model, method = "rf", tuneGrid = tune)
pred_rf_Model_Unemployment <- predict(fit_rf_Model_Unemployment, newdata = Model_test)
RMSE_rf <- sqrt(mean((pred_rf_Model_Unemployment - Model_test$Unemployment)^2))

Results_Model_Unemployment <- data_frame(method = c("lm","knn","xgb","rf"), RMSE = c(RMSE_lm,RMSE_knn,RMSE_xgb,RMSE_rf))

fit_Model_Unemployment <- list(lm = fit_lm_Model_Unemployment, knn = fit_knn_Model_Unemployment, 
                               xgb = fit_xgb_Model_Unemployment, rf = fit_rf_Model_Unemployment)
```

We rebuild our models using the new data sets and compare our results with our previous unemployment model:

```{r unemployment cross data set comparison, echo=FALSE}
Results_Unemployment %>% 
  full_join(Results_Model_Unemployment, 
                                   by = "method",suffix = c("_Original","_Compounded")) %>%
  mutate(method = c("Linear Regression","k-Nearest Neighbors","Gradient Boosting","Random Forest")) %>%
  knitr::kable(col.names = c("Method","Original data set RMSE","Combined data set RMSE"))
```

Our Various Model methodologies are under-performing once we add GDP growth as a predictor so we discontinue this line of inquiry.

### New Annual GDP growth model

```{r combined GDP models, message=FALSE, warning=FALSE, include=FALSE}
# Linear Regression
fit_lm_Model_GDP_Growth <- train(GDP_Growth ~ ., data = Model, method = "lm", trControl = Control)
pred_lm_Model_GDP_Growth <- predict(fit_lm_Model_GDP_Growth, newdata = Model_test)
RMSE_lm <- sqrt(mean((pred_lm_Model_GDP_Growth - Model_test$GDP_Growth)^2))

#k-Nearest Neighbours
tune = data.frame(k = 90:100)
fit_knn_Model_GDP_Growth <- train(GDP_Growth ~ ., data = Model, 
                                  method = "knn", tuneGrid = tune, trControl = Control)
pred_knn_Model_GDP_Growth <- predict(fit_knn_Model_GDP_Growth, newdata = Model_test)
RMSE_knn <- sqrt(mean((pred_knn_Model_GDP_Growth - Model_test$GDP_Growth)^2))

# Gradient Boosting
tune <- expand.grid(nrounds = 50, lambda = c(0,1e-04,0.1,1), alpha = c(0,1e-04,0.1,1), eta = 0.3)
fit_xgb_Model_GDP_Growth <- train(GDP_Growth ~ ., data = Model, 
                                  method = "xgbLinear", trControl = Control )
pred_xgb_Model_GDP_Growth <- predict(fit_xgb_Model_GDP_Growth, newdata = Model_test)
RMSE_xgb <- sqrt(mean((pred_xgb_Model_GDP_Growth - Model_test$GDP_Growth)^2))

# Random Forest
tune = data.frame(mtry = seq(2,10,2))
fit_rf_Model_GDP_Growth <- train(GDP_Growth ~ ., data = Model, 
                                 method = "rf", tuneGrid = tune, trControl = Control)
pred_rf_Model_GDP_Growth <- predict(fit_rf_Model_GDP_Growth, newdata = Model_test)
RMSE_rf <- sqrt(mean((pred_rf_Model_GDP_Growth - Model_test$GDP_Growth)^2))

Results_Model_GDP_Growth <- data_frame(method = c("lm","knn","xgb","rf"), RMSE = c(RMSE_lm,RMSE_knn,RMSE_xgb,RMSE_rf))

Results_GDP_Growth %>% full_join(Results_Model_GDP_Growth, by = "method",suffix = c("_Original","_Compounded"))

fit_Model_GDP_Growth <- list(lm = fit_lm_Model_GDP_Growth, knn = fit_knn_Model_GDP_Growth, xgb = fit_xgb_Model_GDP_Growth, rf = fit_rf_Model_GDP_Growth)

Best_fit_Model_GDP_Growth <- fit_Model_GDP_Growth[[Results_Model_GDP_Growth$method[which.min(Results_Model_GDP_Growth$RMSE)]]]
```

We repeat the previous exercise, this time attempting to predict Annual GDP Growth with Unemployment as a predictor. The results are:

```{r results GDP cross data set comparison, echo=FALSE}
Results_GDP_Growth %>% 
  full_join(Results_Model_GDP_Growth, by = "method",suffix = c("_Original","_Compounded")) %>%
  mutate(method = c("Linear Regression","k-Nearest Neighbors","Gradient Boosting","Random Forest")) %>%
  knitr::kable(col.names = c("Method","Original Data set RMSE","Combined data set RMSE"))
```

This time we find that adding Unemployment as a predictor of Annual GDP_Growth leads to an improvement in our model. Therefore, we use our best performing model to make the predictions.

The below code predicts Unemployment in 2023 and then uses that to predict the Annual GDP Growth of 2023:

```{r 2023 predictions using the combined model, echo=TRUE, message=FALSE, warning=FALSE}
Model_GDP_Growth_2023 <- Model_test %>% mutate(Year = 2023) %>% select(Country_Name,Year)

Model_GDP_Growth_2023 <- Model_GDP_Growth_2023 %>% 
  mutate(Unemployment = predict(Best_fit_Unemployment, newdata = .)) %>%
  mutate(GDP_Growth = predict(Best_fit_Model_GDP_Growth, newdata = .))
```

A histogram of our results shows a similar trend as before although the data seems more tightly clustered with fewer outliers:

```{r histogram gdp growth combined data set prediction, echo=FALSE}
mu_Model_GDP_Growth_2023 <- Model_GDP_Growth_2023 %>% 
  summarise(AU_GDP_Growth = mean(GDP_Growth)) %>% pull()

Model_GDP_Growth_2023 %>%
  ggplot(aes(GDP_Growth)) +
  geom_histogram(bins = 20, color = "black") + 
  geom_vline(xintercept = mu_GDP_Growth_2023, color = "blue", linetype = 2) +
  scale_x_continuous(breaks = c(mu_GDP_Growth_2023,7,seq(-10,20,5))) +
  scale_y_continuous(expand = c(0,0)) + 
  xlab("Annual GDP Growth")
```

Finally by looking at the countries that achieve the targets we find that the trends do support our prediction. In spite of Cote d'Ivoire no longer predicted to succeed we have one more country predicted to succeed than in our last model.

Once again we caution at the inclusion of Libya considering the massive variance it is exhibiting in the data set.

```{r Countries achieving GDP target combined data, echo=FALSE, message=FALSE, warning=FALSE}
Model_GDP_Growth_2023 %>% filter(GDP_Growth >= 7) %>% select(Country_Name) %>% 
  inner_join(GDP_Growth) %>%
  ggplot(aes(Year, GDP_Growth)) + 
  geom_point() + 
  geom_hline(yintercept = 7, color = "red", linetype = 2) +
  geom_smooth(span = 1) + 
  scale_color_brewer("Country",palette = "Dark2") + 
  facet_wrap(.~Country_Name, scales = "free",ncol = 2) + 
  ylab("Annual GDP Growth")
```

# Conclusion

In the Course of the report we set out to assess the progress of AU member states in achieving specific targets set in the First Ten Year Implementation Plan; as well as to predict if those targets would be achieved by 2023.

## Technical findings

On the more technical side we found two important if predictable findings

1. That different indicators are better modeled with different modelling algorithms
2. That because one indicator can act as a predictor for another does not mean the opposite is true

## Analysis Results and Recommendations

In terms of the performance of member states we find that many if not most member states are performing positively in our chosen indicators; however, they are falling short of the targets with only a handful predicted to achieve it by 2023.

This can partly be blamed at how the targets are set. For example, we alluded that a more important indicator for success might be how often a target is reached rather than simply whether or not it is achieved. This would minimize the effect of large variations in our data set such as we saw with the Annual GDP Growth in Libya.

Continent Wide performance indicators; whether measured as the Mean or Median, hide the Variation within the continent with many Member States vastly over or under-performing leading to skewed distributions. 

Stratifying Member states based on commonalities may help to isolate the causes of these variations guiding policy decision.